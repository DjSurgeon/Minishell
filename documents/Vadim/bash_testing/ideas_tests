# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    ideas_tests                                        :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: vjan-nie <vjan-nie@student.42madrid.com    +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2025/08/26 16:16:32 by vjan-nie          #+#    #+#              #
#    Updated: 2025/09/28 11:53:43 by vjan-nie         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

ORIGINAL PIPE

echo $SHELL

comando de bash:

< file1 cmd1 | cmd2 >file2

-----------------------------------------------------

valgrind --leak-check=full --show-leak-kinds=all --trace-children=yes ./minishell

Pruebas comunes:

echo hola mundo | wc -w

ls | grep mini | wc -l


< infile ls -l | wc -l > outfile (debe crear outfile si no está)


< infile grep a1 | wc -w > outfile (sobreescribe si ya hay outfile)


Pruebas errores:

No file:

< infil ls -l | wc -l > outfile
"bash: infil: No existe el archivo o el directorio" (pero crea outfile)


No command:

< infile lx -l | wx -l > outfile
"lx: no se encontró la orden
wx: no se encontró la orden"


+ Valgrind!
valgrind --trace-children=yes

MÁS:

Comando que existe y está en el PATH:

< infile grep ee | wc -w > outfile

Comando con ruta relativa válida:

< infile "./a.out" | cat > outfile (!!! para minishell lo acepta sin comillas, bash ambas)
(impresión prueba en outfile, se ignora infile porque execve ha ejecutado correctamente a.out, con lo que el proceso hijo es reemplazado por el ejecutable)

Comando con ruta absoluta válida: (realpath ./a.out)

< infile "/ruta_absoluta" | cat > outfile

Ruta o comando inválidos:

< infile gre ee | wc -w > outfile
"Orden «gre» no encontrada."


< infile "./no_existe" | cat > outfile
"bash: ./no_existe: No existe el archivo o el directorio"


Múltiples pipes:

< infile ls -l | wc -l | cat > outfile

Here_doc:

ls -l << stop | wc -l | cat >> outfile

Pruebas locas:

< infile ls -l | wc -l | << cat | ls -l > outfile
("cat" se toma como limitador, entra en el proceso here_doc, y luego al terminar hace un ls -l del directorio: parece que los procesos hijos de los pipes van independientemente, y si no se transmite la información no pasa nada. Out devuelve el último ls -l)


< infile ls -l | wc -l | > outfile | cat > outfile
(crea un archivo outfile vacío, supongo que porque el último comando hace cat sin introducir nada, o porque se haya creado en el penúltimo comando de append)

< infile ls -l | wc -l | > outfile | < outfile | cat > outfile


< infile ls -l | wc -l | > outfile1 | < outfile2 | cat > outfile3


< infile lx -l | wc -l | > outfile1 | < outfile2 | cat > outfile3


< infile ls -l | wc -l | > outfile1 | < infile | cat > outfile2

< infile ls -l | wc -l | > outfile1 | < infile cat | cat > outfile2

< infile ls -l | wc -l | << stop | < infile cat | cat > outfile2

Múltiples redirecciones en un comando:

ls >outfile1 >outfile2 >outfile3
(en bash: crea los archivos pero sólo escribe en 3!)

ls >outfile1 >>outfile2 >outfile3

ls >outfile1 >>outfile2 >>outfile3

< infile >outfile cat

<< stop >outfile cat (leaks!!)

< infile <outfile cat
bash: outfile: No existe el archivo o el directorio

ls >outfile1 >>outfile2 >outfile3 | cat >outfile4 >>outfile5 >outfile6
(bash, no escribe nada en los últimos, porque la redirección ya la ha recibido outfile3)

ls | cat >outfile4 >>outfile5 >>outfile6

Extra:

- sleep (para ver que todo se sincroniza)
- unset PATH
- ulimit -n 4 (sólo podemos usar 4 fds?)
- ls y algún otro puede tener bytes still reachable!
- nm -u ./ejecutable (muestra funciones utilizadas)

HEREDOC!

<< stop | wc -l > outfile
ls -l
stop

echo ls -l | wc -l > outfile

sh << stop | wc -l > outfile (biennnnn)

ls | << stop cat | cat > outfile

NUEVOS PROBLEMAS:

< infile "./a.out" | cat > outfile (!!! para minishell lo acepta sin comillas, bash ambas)
(por ahora se queda ejecutando, falta implementación de comillas)

ls >outfile1 >outfile2 >outfile3 (nuestra minishell interpreta los outfiles como comandos!!, con espacio lo coge bien)


BUILTINS:

ls | exit (status: 0)

env | grep USER
unset USER
(unset algo sin key no dice nada ni da error)

export USER=veid


echo hola mundo           # hola mundo\n
echo -n hola mundo        # hola mundo
echo                      # \n
echo -n                   # (no newline)
echo -nnnn hola           # hola   (el comportamiento esperado en bash es tratar todos los -n como válidos)

echo -n -n -n hola        # hola (bash imprime sin salto de línea)
echo -n -e hola           # -e hola (bash NO interpreta -e si -n ya fue activado)
echo -- hola              # -- hola (debería imprimir tal cual, "--" no es opción)

cd /tmp                   # Cambia a /tmp
cd ..                     # Sube un directorio
cd ../otro                # Sube y entra en "otro"
cd                        # No permitido en minishell (no hay HOME), debe fallar

cd ruta/inexistente       # Debería imprimir un error
cd ""                     # no hacer nada
cd .                      # No cambia de directorio
cd /                      # Va al root


pwd                       # Debería imprimir la ruta actual
pwd -L                    # Error o ignorar (no se debe aceptar opciones)
pwd -P                    # Idem

env                       # Lista todas las variables exportadas con valor

env ls                    # Error, minishell no debe permitir esto
env -i                    # No permitido, debe dar error
env VAR=VAL               # No permitido

export VAR=valor          # Crea o modifica una variable
export VAR                # Marca la variable como exportada (sin valor)
export VAR=               # Exporta con valor vacío
export _VAR=ok            # Válido
export VAR=123
env | grep VAR


export 1VAR=valor         # Error: nombre inválido (debe comenzar con letra o _)
export VAR-OTRO=valor     # Error
export VAR=valor extra    # Todo después del = se considera parte del valor
export                    # Lista las variables exportadas en formato declare -x


unset VAR                 # Elimina VAR del entorno
unset _VAR                # Elimina _VAR
env | grep VAR

unset 1VAR                # Si no existe, bash no dice nada ni da error
unset                     # No hace nada
unset VAR1 VAR2 VAR3      # Debe eliminar todas

exit                      # Sale con código 0

exit 42                   # No permitido (debe ignorar o error)
exit hola                 # No permitido
exit 999999999999999999   # No permitido
exit ""                   # No permitido (mi bash sale en todos estos casos!)


