# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    ideas_tests                                        :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: vjan-nie <vjan-nie@student.42madrid.com    +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2025/08/26 16:16:32 by vjan-nie          #+#    #+#              #
#    Updated: 2025/09/25 13:18:09 by vjan-nie         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

ORIGINAL PIPE

echo $SHELL

comando de bash:

< file1 cmd1 | cmd2 >file2

-----------------------------------------------------

valgrind --leak-check=full --show-leak-kinds=all --trace-children=yes ./minishell

Pruebas comunes:

echo hola mundo | wc -w

ls | grep mini | wc -l


< infile ls -l | wc -l > outfile (debe crear outfile si no está)


< infile grep a1 | wc -w > outfile (sobreescribe si ya hay outfile)


Pruebas errores:

No file:

< infil ls -l | wc -l > outfile
"bash: infil: No existe el archivo o el directorio" (pero crea outfile)


No command:

< infile lx -l | wx -l > outfile
"lx: no se encontró la orden
wx: no se encontró la orden"


+ Valgrind!
valgrind --trace-children=yes

MÁS:

Comando que existe y está en el PATH:

< infile grep ee | wc -w > outfile

Comando con ruta relativa válida:

< infile "./a.out" | cat > outfile (!!! para minishell lo acepta sin comillas, bash ambas)
(impresión prueba en outfile, se ignora infile porque execve ha ejecutado correctamente a.out, con lo que el proceso hijo es reemplazado por el ejecutable)

Comando con ruta absoluta válida: (realpath ./a.out)

< infile "/ruta_absoluta" | cat > outfile

Ruta o comando inválidos:

< infile gre ee | wc -w > outfile
"Orden «gre» no encontrada."


< infile "./no_existe" | cat > outfile
"bash: ./no_existe: No existe el archivo o el directorio"


Múltiples pipes:

< infile ls -l | wc -l | cat > outfile

Here_doc:

ls -l << stop | wc -l | cat >> outfile

Pruebas locas:

< infile ls -l | wc -l | << cat | ls -l > outfile
("cat" se toma como limitador, entra en el proceso here_doc, y luego al terminar hace un ls -l del directorio: parece que los procesos hijos de los pipes van independientemente, y si no se transmite la información no pasa nada. Out devuelve el último ls -l)


< infile ls -l | wc -l | > outfile | cat > outfile
(crea un archivo outfile vacío, supongo que porque el último comando hace cat sin introducir nada, o porque se haya creado en el penúltimo comando de append)

< infile ls -l | wc -l | > outfile | < outfile | cat > outfile


< infile ls -l | wc -l | > outfile1 | < outfile2 | cat > outfile3


< infile lx -l | wc -l | > outfile1 | < outfile2 | cat > outfile3


< infile ls -l | wc -l | > outfile1 | < infile | cat > outfile2

< infile ls -l | wc -l | > outfile1 | < infile cat | cat > outfile2

< infile ls -l | wc -l | << stop | < infile cat | cat > outfile2

Múltiples redirecciones en un comando:

ls >outfile1 >outfile2 >outfile3
(en bash: crea los archivos pero sólo escribe en 3!)

ls >outfile1 >>outfile2 >outfile3

ls >outfile1 >>outfile2 >>outfile3

< infile >outfile cat

<< stop >outfile cat (leaks!!)

< infile <outfile cat
bash: outfile: No existe el archivo o el directorio

ls >outfile1 >>outfile2 >outfile3 | cat >outfile4 >>outfile5 >outfile6
(bash, no escribe nada en los últimos, porque la redirección ya la ha recibido outfile3)

ls | cat >outfile4 >>outfile5 >>outfile6

Extra:

- sleep (para ver que todo se sincroniza)
- unset PATH
- ulimit -n 4 (sólo podemos usar 4 fds?)
- ls y algún otro puede tener bytes still reachable!
- nm -u ./ejecutable (muestra funciones utilizadas)

HEREDOC!

<< stop | wc -l > outfile
ls -l
stop

echo ls -l | wc -l > outfile

sh << stop | wc -l > outfile (biennnnn)

ls | << stop cat | cat > outfile

NUEVOS PROBLEMAS:

< infile "./a.out" | cat > outfile (!!! para minishell lo acepta sin comillas, bash ambas)
(por ahora se queda ejecutando, falta implementación de comillas)

ls >outfile1 >outfile2 >outfile3 (nuestra minishell interpreta los outfiles como comandos!!, con espacio lo coge bien)


BUILTINS:

ls | exit (status: 0)

env | grep USER
unset USER
(unset algo sin key no dice nada ni da error)

export USER=veid

